In the CSE 210: Programming with Classes course at Brigham Young University-Idaho, we developed practical projects where we applied four fundamental principles of object-oriented programming. These concepts—abstraction, encapsulation, inheritance, and polymorphism—are not just theoretical, but tools I directly used in my projects like *Eternal Quest* (a goal-tracking system) and *Exercise Tracker* (a physical activity monitor). Throughout this document, I will explain each of these principles in depth, providing concrete examples of how I implemented them and why they are essential for developing professional, flexible, and maintainable software.

Abstraction is the first pillar we explored. This principle involves showing only the essential details of an object while hiding its internal complexity. In my *Eternal Quest* project, I implemented this concept through an abstract class called *Goal*, which defined common methods like *RecordEvent()* and *GetStatus()*. The beauty of this approach was that each specific type of goal (e.g., *SimpleGoal*, *EternalGoal*, *ChecklistGoal*) implemented these methods in its own way, but the main program could interact with all goals through this uniform interface without needing to know the specific details of each one. To better understand this, imagine a music player: when we press the play button, we don’t need to know how the internal audio decoding mechanism works—we just want the music to play. Similarly, abstraction allows us to create components that expose useful functionality while keeping their internal complexity hidden. This proved invaluable when I needed to add a new type of goal weeks later, as I could do so by simply creating a new class that implemented the required methods, without modifying any existing code that interacted with the goals.

Encapsulation was the second principle we rigorously applied. This concept refers to the practice of grouping data and the methods that operate on that data into a single unit (the class), while restricting direct access to the internal components. In the development of my *Exercise Tracker*, I was careful to declare all data fields as private (prefixed with _ such as _distance and _speed) and provided controlled public methods to access and modify these values. For instance, instead of allowing other parts of the program to directly modify the distance traveled in a running activity, I required all accesses to go through methods like *GetDistance()* and *SetDistance()*. To visualize this, think of a cash register: we don’t want anyone to open it and take money directly, but rather have all transactions go through the controlled processes of the register that log and validate each operation. Encapsulation proved its value when, at a later stage of the project, I needed to change how distances were stored (from miles to kilometers). Thanks to encapsulating this data, I could make the change by modifying only the access methods in the relevant class, without needing to search for and update every place in the program where the distance was used.

The third principle, inheritance, allows us to create class hierarchies where child classes inherit characteristics from parent classes while adding or modifying specific behaviors. In the design of *Exercise Tracker*, I created a hierarchy where *Running*, *Cycling*, and *Swimming* inherited from a common base class called *Activity*. This parent class contained all shared attributes and methods, such as *Date* (activity date) and *Minutes* (duration in minutes), while each child class added its own specifics: *Running* stored the distance traveled, *Cycling* kept the average speed, and *Swimming* tracked the number of laps in the pool. A real-world analogy would be vehicles: all of them share common features like wheels, an engine, and transport capacity (inherited from a base "Vehicle" class), but a truck adds heavy-load capacity, while a motorcycle is designed for two passengers. Inheritance proved useful when, as the project expanded, I could create a new *JumpRope* class that inherited from *Activity* and only needed to implement its specific features, automatically gaining all the shared functionality. This significantly reduced code duplication and facilitated maintenance.

Finally, polymorphism completes this set of fundamental principles. This concept allows objects of different classes to respond differently to the same message or method call. In the implementation of *Exercise Tracker*, I took advantage of polymorphism by designing the *GetSummary()* method in the base *Activity* class, which each child class could override to provide a specific implementation. Thus, when the main program iterated over a list of activities and called the *GetSummary()* method on each, it received detailed and specific information for each type of activity without needing to explicitly check the type of each object. To understand this with a real-world example, consider the act of "drawing": if we ask different people to draw a tree, an artist might create a detailed portrait, a child might make a simple drawing, and an architect might produce a technical blueprint—each one is responding to the same request ("draw"), but in their own way. Polymorphism in my project allowed the code to be notably cleaner and more extensible, as new activity classes could be added simply by implementing their specific versions of the polymorphic methods, without requiring modifications to the existing code that processed the activities.

The combined application of these four principles in my academic projects demonstrated their real value in software development. Abstraction allowed me to model complex systems through understandable interfaces; encapsulation protected data integrity and facilitated future modifications; inheritance eliminated code duplication and established logical relationships between components; and polymorphism enabled me to write more generic and extensible code. Together, these concepts transformed my approach to programming, shifting from simply "making it work" to creating robust and professional designs. In a real-world work environment, these principles are even more critical, as they allow development teams to work in a coordinated manner on large codebases, make changes confidently without breaking existing functionality, and extend systems to meet new business requirements. The experience gained from applying these concepts in concrete projects during the CSE 210 course has laid a solid foundation for my development as a professional programmer, equipping me to create software that is not only functional but also well-structured, maintainable, and adaptable to the changes that inevitably arise in the real world of software development.